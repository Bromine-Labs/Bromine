---
import Layout from "../Layout.astro";
import TabStrip from "@/components/TabStrip.astro"; // Import TabStrip
import Lethal from "@/components/Lethal.astro";
import Omnibar from '@/components/Omnibar.astro';
---
<Layout>
  <div class="flex">
    <Lethal/>

              <main class="flex-grow">
        <TabStrip /> {/* Add TabStrip before Omnibar */}
        <Omnibar class="p-8" />
    <div id="frames">
      <!-- Iframes will be dynamically added here -->
    </div>
    </main>

<script>
  import tabStore from '../tabStore.js'; // Path from pages/index.astro to src/tabStore.js

  function handleIframeLoad(event) {
    const iframe = event.target;
    const tabIdStr = iframe.dataset.tabId;

    if (!tabIdStr) {
      console.warn("index.astro: Iframe loaded without a tabId in dataset.", iframe.id);
      return;
    }
    const tabId = parseInt(tabIdStr, 10);
    const activeTab = tabStore.getActiveTab(); // Get active tab for checks

    try {
      // Title Update Logic (existing)
      const pageTitle = iframe.contentDocument ? iframe.contentDocument.title : '';
      const currentTabInStore = tabStore.getTabs().find(t => t.id === tabId);

      if (pageTitle) {
        if (currentTabInStore && currentTabInStore.title !== pageTitle) {
          tabStore.updateTabTitle(tabId, pageTitle);
          document.dispatchEvent(new CustomEvent('tabtitlechanged', { detail: { tabId: tabId, newTitle: pageTitle } }));
        }
      } else if (iframe.src === 'about:blank' || iframe.src === '') {
        const defaultTitle = (currentTabInStore && currentTabInStore.url === 'about:blank') ? 'New Tab' : 'Untitled';
        if (currentTabInStore && currentTabInStore.title !== defaultTitle) {
          tabStore.updateTabTitle(tabId, defaultTitle);
          document.dispatchEvent(new CustomEvent('tabtitlechanged', { detail: { tabId: tabId, newTitle: defaultTitle } }));
        }
      }

      // URL Update Logic (New)
      if (iframe.contentWindow) {
        const newUrl = iframe.contentWindow.location.href;
        // Prevent updating store if URL is effectively blank unless it's a deliberate navigation to about:blank
        // The main check is to see if the newUrl is different from what's already in the store for that tab.
        if (newUrl && (!currentTabInStore || currentTabInStore.url !== newUrl)) {
            // Check for 'about:blank' carefully. If the tab URL in store is not 'about:blank' 
            // but iframe navigates to 'about:blank', it's a valid change.
            // If newUrl is 'about:blank' and currentTabInStore.url is also 'about:blank', no need to update.
            if (newUrl !== 'about:blank' || (currentTabInStore && currentTabInStore.url !== 'about:blank')) {
                 tabStore.updateTabUrl(tabId, newUrl);
                 if (activeTab && activeTab.id === tabId) {
                    document.dispatchEvent(new CustomEvent('activeurlchanged', { detail: { newUrl: newUrl, tabId: tabId } }));
                 }
            } else if (newUrl === 'about:blank' && currentTabInStore && currentTabInStore.url !== 'about:blank') {
                // This case handles navigating from a valid URL to about:blank
                tabStore.updateTabUrl(tabId, newUrl);
                if (activeTab && activeTab.id === tabId) {
                    document.dispatchEvent(new CustomEvent('activeurlchanged', { detail: { newUrl: newUrl, tabId: tabId } }));
                }
            }
        }

        // Attach popstate listener for SPA-like navigation and history changes (New)
        // Ensure it's added only once
        if (!iframe._popStateListenerAttached) {
          iframe.contentWindow.addEventListener('popstate', () => {
            // Check if the iframe still exists in the DOM and is part of a tab
            const currentIframe = document.getElementById(iframe.id);
            if (!currentIframe || !currentIframe.dataset.tabId) return;

            const popstateTabIdStr = currentIframe.dataset.tabId;
            const popstateTabId = parseInt(popstateTabIdStr, 10);
            const currentIframeUrl = currentIframe.contentWindow.location.href;
            
            const tabInStore = tabStore.getTabs().find(t => t.id === popstateTabId);
            if (tabInStore && tabInStore.url !== currentIframeUrl) {
                tabStore.updateTabUrl(popstateTabId, currentIframeUrl);
                const currentlyActiveTab = tabStore.getActiveTab(); // Re-fetch active tab state
                if (currentlyActiveTab && currentlyActiveTab.id === popstateTabId) {
                    document.dispatchEvent(new CustomEvent('activeurlchanged', { detail: { newUrl: currentIframeUrl, tabId: popstateTabId } }));
                }
            }
          });
          iframe._popStateListenerAttached = true;
        }
      }
    } catch (e) {
      console.warn(`index.astro: Error accessing iframe content for tab ${tabId}. This might be due to cross-origin restrictions or detached iframe. Error: ${e.message}`);
    }
  }

  function updateIframeVisibility() {
    const framesContainer = document.getElementById('frames');
    if (!framesContainer) {
      console.error("index.astro: Frames container (div#frames) not found during update.");
      return;
    }

    const allTabs = tabStore.getTabs();
    if (allTabs.length === 0 && framesContainer.children.length > 0) {
        // If no tabs in store, remove all iframes from DOM
        while (framesContainer.firstChild) {
            framesContainer.removeChild(framesContainer.firstChild);
        }
        return;
    }
    
    allTabs.forEach(tab => {
      let iframe = document.getElementById(tab.iframeId);
      if (!iframe) {
        // Create iframe if it doesn't exist
        iframe = document.createElement('iframe');
        iframe.id = tab.iframeId;
        iframe.className = 'w-full h-full'; // Standard classes
        // sandbox attribute can be added here if needed
        iframe.dataset.tabId = tab.id; // Associate with tabId for load listener
        
        // Set initial src. Lethal.astro will handle subsequent loads for active tab.
        // This ensures new tabs get about:blank and existing tabs restore their URL.
        iframe.src = tab.url || 'about:blank'; 
        
        iframe.removeEventListener('load', handleIframeLoad); // Ensure no duplicate listeners
        iframe.addEventListener('load', handleIframeLoad);
        framesContainer.appendChild(iframe);
      }

      // Set visibility based on active state
      iframe.style.display = tab.isActive ? 'block' : 'none';
    });

    // Clean up: Remove any iframes in the DOM that no longer correspond to a tab in the store
    const existingIframes = framesContainer.querySelectorAll('iframe');
    existingIframes.forEach(iframeInDom => {
        const tabExistsInStore = allTabs.some(tab => tab.iframeId === iframeInDom.id);
        if (!tabExistsInStore) {
            iframeInDom.removeEventListener('load', handleIframeLoad); // Clean up listener
            framesContainer.removeChild(iframeInDom);
            console.log(`index.astro: Removed orphaned iframe ${iframeInDom.id}`);
        }
    });
    
    const activeTab = tabStore.getActiveTab();
    if (activeTab) {
        const activeIframe = document.getElementById(activeTab.iframeId);
        if (activeIframe && activeIframe.style.display === 'none') {
            console.warn(`index.astro: Active tab's iframe (${activeTab.iframeId}) was hidden. Forcing display:block.`);
            activeIframe.style.display = 'block'; // Ensure active is visible
        }
         if (activeIframe && activeIframe.src !== activeTab.url && activeTab.url !== 'about:blank') {
            // If active tab's URL changed in store (e.g. by Lethal) and iframe src is different
            // AND it's not just about:blank (which Lethal might not set src for initially)
            // This could be a place to update src, but Lethal should primarily handle active iframe src.
            // console.log(`Active iframe ${activeIframe.id} src ${activeIframe.src} differs from store URL ${activeTab.url}. Consider sync.`);
        }
    } else if (allTabs.length > 0) {
        // This state should ideally not be reached if tabStore always ensures an active tab when tabs exist.
        // If it is, it implies an issue with tabStore logic or its usage.
        console.warn("index.astro (updateIframeVisibility): No active tab found in store, but tabs exist. UI may be inconsistent.");
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    updateIframeVisibility(); // Initial call
    // Ensure that if TabStrip adds the first tab, we update iframes
    if (tabStore.getTabs().length > 0 && !document.getElementById(tabStore.getActiveTab()?.iframeId)) {
        console.log("index.astro: Active tab's iframe not found on initial load, re-running updateIframeVisibility.");
        updateIframeVisibility();
    }
  });
  document.addEventListener('tabchanged', () => updateIframeVisibility());
  // Listen for new tabs being added (e.g., by Omnibar or TabStrip itself if not reloading)
  document.addEventListener('tabadded', () => updateIframeVisibility()); 
  // Listen for tabs being closed (e.g., by TabStrip if not reloading)
  document.addEventListener('tabclosed', () => updateIframeVisibility());


</script>
              

</Layout>
